import { createSlice, nanoid } from '@reduxjs/toolkit';

const initialState = {
  todos: [{ id: 1, text: 'hello world' }],
};

export const todoSlice = createSlice({
  name: 'todo',
  initialState,
  reducers: {
    addTodo: (state, action) => {
      /* action.payload is assumed to be the text for the new todo. why so? 
        The assumption that action.payload is the text for the new todo is based on the context and the common convention used in Redux applications. In many Redux applications, it's a common pattern to use the payload property of an action to carry data relevant to that action. */

      const todo = { id: nanoid(), text: action.payload };
      state.todos.push(todo);
    },
    removeTodo: (state, action) => {
      state.todos = state.todos.filter((todo) => todo.id !== action.payload);
    },
    updateTodo: (state, action) => {
      state.todos = state.todos.map((todo) =>
        todo.id === action.payload.id ? { ...todo, text: action.payload.text } : todo
      );
    },
  },
});

export const { addTodo, removeTodo, updateTodo } = todoSlice.actions;

export default todoSlice.reducer;



/* In Redux reducers, the state represents the current state of the application, and the action represents the action that was dispatched to trigger a state change. Let's break down these concepts in the context of your Redux slice:

state:
In your example, state is the current state of the todoSlice. It includes a property called todos, which is an array of todo objects.
The state is modified within each reducer function to produce a new state. Redux Toolkit takes care of immutability behind the scenes, so when you modify the state, you are actually creating a new state object.

action:
An action is an object that describes the intention to change the state. It has a type property that defines the type of action and, optionally, a payload property that can carry additional data needed for the state change.
In your example, the actions are defined in the reducers object of the createSlice function. For instance, addTodo, removeTodo, and updateTodo are action creators generated by Redux Toolkit. When you dispatch these actions, they trigger the corresponding reducer functions.
Here's a brief explanation of how state and action are used in your reducers:

In the addTodo reducer, the new todo is added to the state.todos array using the push method.
In the removeTodo reducer, the state.todos array is filtered to exclude the todo with the specified id.
In the corrected updateTodo reducer, the state.todos array is mapped over, and for the todo with the matching id, a new todo object is created with the updated text. The other todos remain unchanged.
When you dispatch these actions, Redux will call the corresponding reducer functions, passing the current state and the action as arguments. The reducer functions then determine how the state should be updated based on the action type and payload.






 */
